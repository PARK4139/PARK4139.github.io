

wireless communication

	data의 전송

	sound

	light	

	LASER

	wave



RF(Radio Frequency)

	





transmitter

	보내고자 하는 data를 radio로 modulation하여

	PA(Power Amplifier)전력증폭기를 통해 transmit radio



reciever

	recieved radio를 Demodulation하여 recieve data







쌍방향 wireless communication

	Tx(Transmit Frequency),Rx(Receive Frequency)를 별도로 두어 동시에 송수신이 가능하도록 고안된 wireless communication







frequency

	파장과 반비례







사람이 만들어 낼 수 있는 소리

	Frequency=87Hz(저음)-1200Hz(고음)



Audio Frequency(사람이 들을 수 있는 frequency)

	Audio Frequency=15~20,000Hz



Bandwidth

	각각의 초음파를 이용하여 communication하는 wireless기기들이 혼선 없이 자신의 wireless signal를 찾아내려면 다른 signal와 겹치지 않는 자신의 frequency 영역을 가져야 하는데

	frequency는 엉뚱한 frequency를 잘못 사용할 경우 범죄나 사고가 일어날 수 있으므로 정부에서 용도에 따른 frequency 분배를 하고 있다

	그니까 world 나라별 각 정부(우리나라 방송communication위원회와 한국radio진흥원)에서 정한 용도에 따른 frequency 범위들을 뜻하는 것 같다





frequency bandwidths character

	low bandwidth frequency

		속도가 떨어진다

		파장이 길어 먼거리 radio가능

	high bandwidth frequency

		대량의 data를 빠르게 전송 가능

		직진성이 높다

		수신 거리가 짧다



300MHz-30GHz

	이동communication 및 wireless LAN

	



3G

	3세대 이동communication

	WCDMA(Wideband Code division multiple access)(HSDPA)

	2007년 한국에서 WCDMA망이 상용화 되었다.

	WCDMA HSDPA는 이론상 14.2Mbps까지 data communication이 가능한 초고속 wireless망이고 빨라진 datacommunication속도 덕분에 영상통화가 가능하고 멀티미디어 수준의 인터넷 역시 가능해졌다.

	또한 유심chip을 탑재하여 금융서비스가 가능해졌다.













근거리 wireless communication







IR(Infrared Ray)

	modulation circuit

	복조 circuit



FM(Frequency Modulation)







antenna 필요성

	전자파를 효과적으로 공중에 Radiation하기 위해서는 antenna가 필요함.



antenna size

	signal의 파장과 밀접하며 음성과 낮은 frequency를 그대로 방사하기 위해서는 수백 Km의 antenna가 필요함. 

	100hz의 frequency 성분을 갖는 modulation되지 않은 오디오 signal의 경우 antenna의 길이가 300km정도 필요. 

	100Mhz로 modulation된 fm방송의 경우 약 1m의 antenna 필요.

antenna length

	파장과 비례

	low frequency signal를 high frequency signal에 실려 보낼경우 불과 몇 Cm정도로도 가능함.









Modulation의 필요성 

1.효율적인 전송, Radiation의 편리



2.modulation for hardware 제한의 극복

    . communication system의 desgin는 사용이 가능한 hardware와 가격의 제약을 받으며 hardware의 성능은 사용되는 주 

       파수의 따라 결정된다. modulation는 desgin자에게 hardware 제한을 극복할수 있는 frequency 영역으로 signal를

       옮길수 있게 해준다.



3.modulation for reducing noise and 간섭

   . communication system에서 noise과 간섭은 피할 수 없는 현상이나 modulation방식을 적절히 선택하면 이를 저감

       시킬 수 있음.

   . noise과 간섭의 제거효과를 보기 위해서는 더 넓은 대역폭이 요구되므로 system desgin시 대역폭

       과 간섭의 적절한 조정이 필요하게 됨

 

4.modulation for frequency 할당

     . 동일 frequency로 두 signal를 전송한다면 상호간에 간섭 영향으로 전송이 어렵게 될 수 있음.

     . 두signal를 각각 서로 다른 frequency로 modulation하여 송신한다면 상호간에 혼신 없이 communication로를 설정

       할 수 있게 됨.

 

5.modulation for 다중화

     . 여러개의 signal를 한개의 전송매체로 보내고자 한다면 높은frequency로 modulation하여 다중화 하여 한

       꺼번에 많은 signal를 다중화 하여 전송할 수 있음. 





















modulation 방식

	Bi-Phase

	ASK or OOK (Amplitude shift keying or on-off keying)

	PDM or PWM(pulse duration or pulse width Modulation)





PWM



duty rate





chip

	input이 5v또는 0v를 구분할 수 없다



circuit	

	5V의 voltage을 받으면 1로 인식(HIGH)

	0V의 voltage을 받으면 0으로 인식(LOW)



floating

	chip이 목적에 의한 5v,0v가 아닌 0v<x<5v의 current가 흐르는 상태

	chip이 오작동하게 하는 원인



	

floating의 해결

	pullup resistor

		opened switch 있을 때 chip에는 항상 5V의 voltage이 가해진다. 따라서 circuit에 입력을 몰라도 항상 5V의 voltage을가진 상태

		closed switch 그라운드 쪽으로 current가 흐르게 되며 circuit의 voltage은 0V가 되며, 1을 입력한 것으로 인식 

	pulldown resistor

		opened switch 그라운드와 연결되어 있으므로 current가 항상 그라운드로 흐르게 되어 0V가 된다

		closed switch 소량의 current가 저항을 통해 그라운드로 흘러 나가지만 많은 양의 current가 circuit(pin)로 흘러 5V가 된다. 따라서 1이 입력된 것으로 인식

	

	

	



flip-flop

	1bit를 기억하는 logic circuit

	전원이 공급되는 한, 상태의 변화를 위한 signal(클럭)가 발생할 때까지 현재의 상태를 유지하는 logiccircuit

	다른 circuit로 부터 출력값을 변경하라는 펄스 signal(Clock)를 보낼 때까지 현재의 상태 출력값을 유지하는 logiccircuit

	레지스터를 구성하는 기본 소자

	레지스터를 구성하는 기본 소자

	2개의 NAND 또는 NOR gate를 이용하여 구성된다



flip-flop 종류

	SR Flip-Flop

		SR Flip-Flop의 입력 S=1, R=1 이 입력되면 0도 1도 아닌 중간값을 갖는 상태가 되는 문제점을 가진다

	D Flip-Flop

		SR Flip-Flop의 입력 S=1, R=1 이 입력되면 0도 1도 아닌 중간값을 갖는 상태가 되는 문제점을 보안한 것

	JK Flip-Flop

		SR Flip-Flop에서 발전된 것

	



Complements보수

	컴퓨터에서 중요한 의미를 지닌다.

	간단하게 보수의 의미는 반대로 세어 가는 수

	n의 보수는 주어진 수치의 각 자리의 값을 n-1에서 뺄셈을 하고 최하위 자리에 1을 더하여 구하는 수치다. 

	즉 10 진수 100까지의 수를 생각한다면, 25의 수는1에서 세어 가면 25번째의 수이지만, 반대로 100에서 세어 가면 75번째 수이다











computer

	digital circuit이 주를 이루는 것 같다

	



1 byte

	최대 0에서 255 까지 수를 표현 가능

	자리<->bit

	8자리<->8bit

	1 byte=8 bit 

1bit

	2 진수(1,0)로 표기된다

	current가 흐를 때<->1

	current가 흐르지 않을 때<->0

	1과 0으로 표현





부호화 절대치(Signed magnitude) 방식

	음수를 표현하기 위해 사용

	1byte의 첫번째 최상위 비트를 부호비트로 사용 

	1byte의 첫번째 최상위 비트를 제외한 나머지 bit를 숫자 비트로 사용한다

	7bit를 이용해 숫자를 표현하므로 0 에서 127 까지 표현인 된다. 





부호화 절대치(Signed magnitude) 방식의 부호비트

	부호비트가 0 인 경우는 양의 정수를 의미

	부호비트가 1 인 경우는 음의 정수를 의미

	

부호화 절대치(Signed magnitude) 방식 문제점

	하지만 이 방식에는 문제점이 몇 가지 발생한다(-0,0,+0의 구분이 생기며 산술 계산에 오류가 발생한다





부호화 절대치(Signed magnitude) 방식 문제점 해결

	2의 보수법을 이용한다

	0에서 127까지를 양의 정수의 범위로 두고 128에서 255까지는 음의 정수의 범위로 둔다







































TX ?

RX?















Variable 구성

	type+name+value

declare

	정의 되지 않은 것들은 define정의하여 call하여 사용해야 한다

	이미 정의 되어있는 것들은 call하여 사용하면 되고

	일부만 정의 되어 있는 것들은 나머지 일부를 유저가 정의를 내리고 사용해야한다



digital pin을 가지고 control하기





Variable Scope

	변수 범위



Initializing Variables

	변수 초기화

	그것들이 선언되지 않은 경우 또는 변수 (초기 값 할당) 초기화 될 수있다

	항상 그러나 일부 다른 목적으로 접근하기 전에 변수가 유효 data가 있음을 재확인하는 좋은 프로그래밍 방법입니다.



Variable Rollover

	변수 "를 통해 롤"최대 용량 그들은을 초과하게되면 다시 최소 용량이 두 방향으로 일이 있습니다.

	

variable types

	char

	int

	byte

	unsigned int

	long

	unsigned long

	float

	double







bootloader

	arduino board에 스케치를 업로드



programming error

API



constants

	arduino에서 이미 정의 된 표현

	

constants 종류

	false<->0,true<->1을 포함한 그 이상 boolean sense부울 의미

	HIGH,LOW	



digital pin mode

	INPUT

	INPUT_PULLUP

	OUTPUT

	



setup()

	sketch를 시작할 때 한 번 호출call됩니다

	pin mode를 설정하거나 library를 초기화하는 등의 설정 작업을 할 수있는 좋은 place입니다

	아두 이노 보드의 각 파워 업 또는 리셋 후, 설정 기능이 한 번만 실행 등, 라이브러리 사용 시작, 변수, 핀 모드 초기화 하는데 사용합니다.





loop()

	초기화하고 초기 값을 설정, 

	루프 () 함수는 이름에서 알 수 정확히 무엇을 수행하고 프로그램을 변경하고 응답 할 수 있도록, 

	연속적으로 반복 설정 () 함수를 만든 후. 

	적극적으로 아두 이노 보드를 제어하는 데 사용합니다.







setup(),loop()

	당신은 setup(),loop() 필요로하지 않는 경우에도,스케치에서 두 기능을 포함해야합니다.



각각의 pin들은 서로 다른 특성을 가지므로 datasheet의 참조가 필요하다



잘못된 circuit구성은 pin을 죽게 만들기도 한다







pin은 hardware적으로 pullup resistor pin인지 정해져 있으며

	software적으로 input pin인지 output pin인지 결정할 수 있다



analog pin



input pin

	입력 핀은 핀의 앞에 100 Mega Ω의 직렬 저항에 해당 그들이 샘플링하는 circuit에 매우 작은 요구를합니다

	current를 받을 수 있다



pullup resistor with input pin

	종종 이것은 아무런 입력이 없으면 알려진 상태로 입력 핀을 조종하는 것이 유용하다. 

	이것은 (+ 5V까지) 풀업 저항을 추가하면, 또는 입력의 풀다운 저항 (접지 저항) 수있다. 

	10K 저항은 풀업 또는 풀다운 저항에 대한 좋은 값

RX pin?





GPIO pin범용 입 / 출력 핀







analog input pins on an Arduino chip (Atmega8, Atmega168, Atmega328, or Atmega1280)

	A/D converter를 가진다 따라서 GPIO 기능이 되는것 같다



The Atmega datasheet를 구해서 공부해서 arduino를 완전히 이해하여 사용하는 것이 중요할 듯하다





Pin mapping

	







analogWrite



output pin

	maximum 40mA까지 보낼 수 있다

	핀에서 maximum current 소모가 특정 응용 프로그램에 필요한 경우를 제외하고 470Ω 또는 1K 저항을 하여 출력 핀에 연결하는 것이 좋습니다.





digitalWrite()

	Write a HIGH or a LOW value to a digital pin.





digitalRead()

	Reads the value from a specified digital pin, either HIGH or LOW.

	



delay()

	ms단위로 delay할 수 있다

	일반적으로 밀리 세컨드의 10 년대보다 긴 이벤트의 타이밍 지연 ()의 사용을 피하십시오.









PWM(Pulse Width Modulation)

	



architecture







arduino memory

	There are three pools of memory in the microcontroller used on avr-based Arduino boards

	Flash memory (program space)

		is where the Arduino sketch is stored

	SRAM (static random access memory)

		is where the sketch creates and manipulates variables when it runs.

		volatile휘발성

		전원이 순환 될 때도 손실

	EEPROM

		is memory space that programmers can use to store long-term information

		non-volatile비휘발성





The ATmega328 chip(in Arduino UNO)

	Flash  32k bytes (of which .5k is used for the bootloader)

	SRAM   2k bytes

	EEPROM 1k byte

	EEPROM Library 1024 byte



The ATmega2560(in Arduino MEGA2560)

	Flash  256k bytes (of which 8k is used for the bootloader)

	SRAM   8k bytes

	EEPROM 4k byte

	EEPROM Library 4KB(4096 byte)에 512 byte

SRAM을 이용할 때 

	많은양의 data를 한번에 표기하려한다면 주석을 제거하는 것도 중요하며

	SRAM으로 제대로 작동하지 않는 다면 data 구조를 단축할 필요가 있다

	(필요한 최소의 data 형식을 사용해야 한다)

	PROGMEM 키워드를 사용한다

	

EEPROM을 사용하려면

	EEPROM Library를 참조









EEPROM Library

	EEPROM에 들어가 있는 program을 말하는 것 같다



EEPROM library function

	EEPROM.read()

	EEPROM.write()

	EEPROM.update()

	EEPROM.get()

	EEPROM.put()

	EEPROM[]

		Syntax

			EEPROM[address]

	







digitalWrite(A0, HIGH);  // set pullup on analog pin 0 





pinMode (A0, OUTPUT);

digitalWrite (A0, HIGH);







pinMode(pin, INPUT);           // set pin to input

digitalWrite(pin, HIGH);       // turn on pullup resistors













#include <avr/pgmspace.h>

















setup() example 

int buttonPin = 3;



void setup()

{

  Serial.begin(9600);

  pinMode(buttonPin, INPUT);

}



void loop()

{

  // ...

}



















loop() ex

const int buttonPin = 3;		// 설정이 초기화 직렬 및 버튼 핀

void setup()

{

  Serial.begin(9600);

  pinMode(buttonPin, INPUT);

}



					// 루프 버튼 핀마다 확인하여,

					// 시리얼을 보내드립니다 그것을 누르면

void loop()

{

  if (digitalRead(buttonPin) == HIGH)

    Serial.write('H');

  else

    Serial.write('L');



  delay(1000);

}











HIGH로 설정 핀 (13)은 1 초 길이의 지연을 만들고, LOW로 다시 핀을 설정합니다. pinMode() ex

int ledPin = 13;                 // LED connected to digital pin 13

void setup()

{

  pinMode(ledPin, OUTPUT);      // sets the digital pin as output

}



void loop()

{

  digitalWrite(ledPin, HIGH);   // sets the LED on

  delay(1000);                  // waits for a second

  digitalWrite(ledPin, LOW);    // sets the LED off

  delay(1000);                  // waits for a second

}

















program code example 1

pinMode(13, OUTPUT);             //pinMode(pin, OUTPUT);

//pin은 누구의 모드를 설정하고자하는 핀의 수

//









program code example 2

int pin = 13;   

int pin2 = pin;

pin = 12; 

              //pin has the value 12; pin2 is still 13.







program code example 3

int pin = 13;               //pin 의 value를 13으로 declare

void setup()			//void setup무효 설정

{

  pinMode(pin, OUTPUT);

}

void loop()			//void loop공간 루프

{

  digitalWrite(pin, HIGH);

} 





program code example 4

int pin = 13;

void setup()

{

  pin = 12;

  pinMode(pin, OUTPUT);

}



void loop()

{

  digitalWrite(pin, HIGH);

} 





program code example 5

void setup()

{

  int pin = 13;

  pinMode(pin, OUTPUT);

  digitalWrite(pin, HIGH);

} 

In this case, the variable pin can only be used inside the setup() function. If you try to do something like this:



void loop()

{

  digitalWrite(pin, LOW); // wrong: pin is not in scope here.

} 

"오류 : '핀'이 범위에서 선언되지 않았다"당신은 이전과 같은 메시지가 나타납니다.

즉, 당신이 어딘가에 당신의 프로그램에 핀을 선언 한 경우에도, 

당신은 그것의 범위를 벗어난 곳을 사용하려고하고 있습니다.



왜 당신이 궁금 할 것이다,

당신은 모든 변수는 글로벌하게하지 않을까요? 나는 변수를해야 할 수도 있습니다 

어디 모른다면 결국, 왜 난 그냥 하나의 기능에 자사의 범위를 제한해야합니까? 

대답은 쉽게 그것을 어떻게되는지 알아낼 수 있다는 것입니다. 

변수가 글로벌 경우, 그 값은 변수에 무슨 일이 일어날 지 알 수있는 프로그램 전체를 

이해할 필요가 있음을 의미하는 코드 어디에서나 변경 될 수 있습니다. 

당신의 변수가 예상하지 않은 값이 있으면 값이 변수가 제한된 범위를 

가지고있는 경우 어디에서 왔는지 예를 들어, 

그것을 알아 내기 위해 훨씬 더 쉽게 할 수 있습니다.















ex 6

void setup()

{

  pinMode(ledPin, OUTPUT);      // sets the digital pin as output출력으로 디지털 핀을 설정

}

		//two parameter(ledPin,OUTPUT)을 전달pinMode () 함수를 call



















ex 7

digitalWrite(ledPin, HIGH);	//ledPin(아마도 pin 13으로 정의 되어 있는듯 하다)을 HIGH로 또는 5volts

digitalWrite(ledPin, LOW);	//LOW로 하는 것은 ground 또는	0volts













ex 8

delay(1000);	//1000ms(1s)를 delay한다 



























digitalread() ex

int ledPin = 13; // LED connected to digital pin 13

int inPin = 7;   // pushbutton connected to digital pin 7

int val = 0;     // variable to store the read value



void setup()

{

  pinMode(ledPin, OUTPUT);      // sets the digital pin 13 as output

  pinMode(inPin, INPUT);      // sets the digital pin 7 as input

}



void loop()

{

  val = digitalRead(inPin);   // read the input pin

  digitalWrite(ledPin, val);    // sets the LED to the button's value

}























EEPROM ex

#include <EEPROM.h>

int a = 0;

int value;



void setup()

{

  Serial.begin(9600);

}



void loop()

{

  value = EEPROM.read(a);



  Serial.print(a);

  Serial.print("\t");

  Serial.print(value);

  Serial.println();



  a = a + 1;



  if (a == 512)

    a = 0;



  delay(500);

}









































