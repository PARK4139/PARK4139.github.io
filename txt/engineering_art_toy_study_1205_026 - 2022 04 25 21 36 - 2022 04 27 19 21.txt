비드맨

구슬동자

짱구는 못말려

사이버포뮬러

카트라이더 자동차

메이플스토리

나홀로 집에







마테리아

로드포테 그리프



그렇게 사과하지 않아도 되요...





멀리날아가버린

주우려 따라다니는 





호시이노?...

자아...아게루





I AM WILLING TO DIE FOR YOU

I AM WILLING TO LIVE FOR YOU







가로등

활주로



사랑

산책

바람소리

향기





지금  데이트해주겠다고 한거죠!



데에토 시테쿠레루테....

데에토

하이

데에토 시테쿠다사이

하이

야소쿠데스요!

하이

요로시쿠 오네가이 시마스









불행을.............줄수 없으니까.........

작은 불행뿐만이 아니야.........

죽을 수도 있어......









............,.........,........,.........,........,..........,의 불행을 내가 가지고 있으니까...

...들의 불행을 모두 ...가 가져갔거든

........가 가져가? 우리들의 불행을 .......









너희들이 다시 나눠갔는 거야..............

난 싫어 싫어!

나도 싫어!

......알았어......그럼 너희들에게 다른 불행을 안겨줄게









..........우리가 다시 나누는 거야   원래부터 우리가 짊어지고 살아가야 했었던 것이니까

가져가 우리들의 불행을









건강한 몸을 주기 위해서............부모인 ........는 스스로의 대신 불행하게 되었어.........

덕분에 ......는 건강한 몸을 얻었어















........를 구하기 위해서........







영령이 되어 ................................를 지켰어











.............는 고치를 만들어 우리를 지켜주었어...............









낙인이 없어졌어.........

구해진거야....







부탁할게....







사람을..........미워하지 말아주세요............







낳은거야

















     원래 우리가 가져갔던 것이니까.....





(ㅇ......o)





(0.....0)















누군가에게 말하면 불행을 주는 것이지





그걸로 괜찮아.....

그걸로 된거야....







이번생에는 내 차례니까.......울지마.......













이곳은 신발을 벗고 올라가야 하는 곳이야

신발장

슬라이드 도어



다락방



다리









나쁜 뜻이 있었던 것은 아니잖아?...





하즈키







하지크가 괜찮다면........조금더 생각하게 해줘....







아소코시카 나이..............

나에겐....그곳밖



와타시니토와 얏토 미츠케타 바쇼난다......







젖었지......늦었지.....

너머졌지



아팠지?..







키키타이 코토오 아루카모.....

카모?...

아루........





마테테 이타테시마스

기다리고 있었습니다...







코코데 이이 아리가토우





카제가 이타카라...





이타카



너멍져











마법사이야기







2층집 다라케

2층 구조

다락방구조

온통

온통







하시테 쿠루........

뛰고 올게







하이!

여기!



이렇게 추운날 이렇게 잘 뛸수있네...?





싫은 계절이 오네?...







닿지 못하는 ........





내가 만든...........내가 표현한 것이에요







자아 오네가이

자아?..

오네가이 시마스!







그러니까 보이지 않는 척.......해야했어

















돌아갈래......

어째서..........그런 얼굴 하는 거야...?....











그때까지 괜찮다면...저랑 사귀어 주세요....

하이...









안정이 될때까지.........안아주세요........





말할게........







그렇게 멀뚱멀뚱 쳐다보지마

(엄청 귀여우니까...)





우레시이나...

이런거....고마워





기뻤어........코미야가 좋아해라고 말해줬던 것....





이즈미를 따라온게 아니니까











나조노 덴코생 케토

이상한 전학생 얻었어!



알았어......오늘은 포기할게







만일....그때 곁에 있었다면.......

















농구펌프

슬라이드 도어















































물총

컴퓨터로 사용하는 알람시계 프로그램



화단



유치원 선생님



대학교를 다시 가는 것







흑색,그래이,미래형











부추

양파

마늘





식충식물

공기정화 식물













코코아파우더

치즈아이스크림

에스프레소시럽

케익

















그렇게 조그만 아이가 그렇게 큰 번개를...

다수에게 ?기는 스와루...

계속 먹을 수 있는 캐릭터

















라프텔

파르테엘

라프테엘

미노아

미노하





깨어나지 못하는 .......아이를......





거대한 이빨







부분 변화을 시작하였어



몸의....해방.......





처음에는

미각.........

시력.........

청력.........

촉각.........

기억........

을 앗아가

결국....육체를 빼앗기는 것







나는 몸이 두개야......







엄청난 신체능력을 가지고 있었어!

나는 보았었으니까!





...를 되돌리려면 댓가로 ............를 위해 누군가를 바쳐야만 해...









번갈아가며 살아가야 해........ 한 생에서 같이 살아갈 수 없어......





















거대한 창을 소환했어

 



.. 의 뼈가루





...의 뼈 파편에







야바이............

......는 각성을 하면      심장이........멈추었어.........











아무도 찾지 못하는 장소에 숨겨두었어........







자세히 설명해 줄게!!







우리는 챔피언의 트랙







키즈다라케노 ......







아픔을 동반한 빠른 회복







응 괴로워

비와 도깨비

상처

도깨비



우비 도깨비



강력한 손바닥



새겨듣는

잊혀지는



아레나스

다이프

다스크

크아일

크타일



크라톤

라크론

라크톤



크라엘

크라엘라





하인트레니







다리                              디자인





라인트레이서

humvee

space suttle discovery

exploer

INTERNAL ISS



썩지않는 일어나지 않은 여자마법사 





약을 먹어서 이 상태로 유지하고 있어







티라미슈

허니브레드





뚜껑있는 냄비 그린

책상

오븐용기

오븐

사이드테이블

트롤리

수납벤치

미니어쳐

목재

미세먼지 먹어주는 식물

줄자



라텍스

메모리폼

수면과학







RC CAR TURNER 형 침상





두가지 나무를 섞어서 만들면 색상이 아름답다



SOFT WOOD

	CEDAR WOOD

		삼나무

		옹이 작음

		하얀톤

HARD WOOD

	ACACIA WOOD

	옹이 큼

	붉은톤



세라믹 타일 바닥





SEO CLASS 원목

다니엘우드

FIXA

친환경 DIY 가구 전문 브랜드

PROSUMER

1인 가구





MORA 선반 책상

고무나무

선인장







친환경 본덱스 정품	수용성 아크릴 폴리우레탄 바니쉬







케네스

테네로

파테이

블

아그네스

루비로직 퀸

킹사이즈

패브릭

헤더막스





600







LEVEL 2 ART TOY

LEVEL 2 (DIY class)

level 9 SUPER TOY (SUPER QUALITY)

	인테리어 가치도 있으면서

	장난감이 되기도하며

	과학적인 원리를 이용하여 움직일 수 있도록 한다

	DIY를 좋아하는 

	경제적인

	친환경적인 

	인류를 위하는	

	조종하게 해보아야 대단함을 느끼고 관심을 가질 수 있다

	

ART TOY

	FPV SYSTEM





 





RACING MAP

	에스컬레이터

	엘리베이터

	리프트

	JUMP대

	드론 경기장

	0드론 경기 룰



RECING MAP LEVEL 2 BLACK LINE

	블랙 라인이 오픈되었습니다



RACING MAP LEVEL 3 BLUE LINE

	블루 라인에서 경기를 진행할 수 있습니다





퀄리티 피그엘





3평 규모의 인테리어

	최고의 안락함을 선사할 수 있는 가구

	바닥타일

	얇은 러그

	영화를 볼 수 있어야 한다 

 



꿈의 생태도시

	멀티 발전기 만들기

		펠티어소자

		태양열 발전기

	친환경농법

	하수종말처리 SYSTEM

	 폐기물종합처리 SYSTEM

	소형 에어컨디셔닝 SYSTEM

		소형 제습기

		소형 공기청정기



무주군 반딧불축제























http://ko.wikipedia.org/wiki/MQ-9_%EB%A6%AC%ED%8D%BC

http://en.wikipedia.org/wiki/General_Atomics_MQ-1_Predator

http://blog.daum.net/baba1905/2323692

http://ko.wikipedia.org/wiki/MQ-1_%ED%94%84%EB%A0%88%EB%8D%B0%ED%84%B0

https://www.youtube.com/watch?v=Vz6Hp2kBMGk



FPV racing

https://www.youtube.com/watch?v=a8JyCGXrFbk

https://www.youtube.com/watch?v=NsxyV-kgfio

https://www.youtube.com/watch?v=COzD3DVNL-8

https://www.youtube.com/watch?v=nt6kYWbMQIM

https://www.youtube.com/watch?v=Itrh2NNaQVE

https://www.youtube.com/watch?v=MUd5_Q14X_8

https://www.youtube.com/watch?v=8nwT7mdAmW8

https://www.youtube.com/watch?v=GfxdeRx2fLA

https://www.youtube.com/watch?v=0JpAOwdBfkg

https://www.youtube.com/watch?v=6orsE3ZDp9s

https://www.youtube.com/watch?v=_eVw4djtjt4

https://www.youtube.com/watch?v=WErhtZjDONY





rc FPV racing은 copilot이 필요하다 왜냐하면 시야를 망치면 컴백 홈을 하지 못할때







https://www.youtube.com/watch?v=pN4w7JA7MpU

https://www.youtube.com/watch?v=xizqU8r0BwI

https://www.youtube.com/watch?v=2GSf2Oe2g04









GOOD ANIMATION

https://www.youtube.com/watch?v=GDz5yuxfgg0&list=FLDMWBmLzUrfFE6OnNTa4z5w





ARDUINO

http://arduino.cc/en/Reference/HomePagehttps://www.youtube.com/user/AHNHEEWOOK/videos

http://arduino.cc/en/Main/Products

http://www.hardcopyworld.com/ngine/aduino/index.php/archives/category/arduinomanual/page/5



http://cafe.naver.com/arduinostory















...................................................................................................................................................................................



operation of NPN-transister

	C=+xv

	E=-xv

	B=+xv(ON) or B=-xv(OFF)



	direction of I:C→E





PNP-transister

	C=-v

	E=+v

	B=-v(ON) or B=+v(OFF)



	direction of I:E→C









remote communication

	wireless 근거리 communication

		RF(Radio frequency)

		IR

		Bluetooth

		WLAN(wireless LAN)







Infrared Data Association(IrDA)

	주로 근거리에서 smart phone 간 간단한 data를 교환할 때 유용하게 사용

	기본 communication거리는 1m

	





wifi communication

bluetooth communication













ray





IR

	파장 of IR=약 780nm~1mm의 전자기파

	스펙트럼 위치상 가시광선 영역에서 파장이 가장 긴 적색(赤)의 밖(外)에 위치

	IR 보다 파장이 긴(>1mm) 바로 옆 영역은 bluetooth나 WiFi communication에서 사용하는 Microwave가 위치



	IR 발산지:IRED,태양광,형광등





Kinds of Infrared Rays

	Infrared Rays

		근IR

		중IR

		원IR

	이 중 대부분의 영역은 '열선'이라 불리는 원 IR(4㎛~1mm)이 차지하고 있습니다.









근 IR(780nm~2000nm영역)

	가시광선보다 파장이 길어서 회절이 잘 일어나고 

	human의 eye으로 인지할 수 없으며

	원IR과 달리 열을 발생시키지 않으므로 근거리 communication 목적으로 사용하기에 적합

	가전제품의 remote controllor이 근IR을 많이 사용

	양방향 communication이 가능

	국제 표준으로 지정된 IR communication은 오늘날 널리 보급된 













Infrared Rays Emitting Diode(IRED)

		Infrared Rays을 발생

		보통 900nm 전후 영역에 분포

		Peak Wavelength(중앙 파장)

		Bandwidth(대역폭)

		WAVELENGTH RANGE

	[EXAMPLE]

		Peak Wavelength=880nm

		,Bandwidth=50nm

		이면

		Infrared Rays Emitting Diode에서 발산되는 WAVELENGTH RANGE=855nm ~ 905nm

	[REFERENCE]

		communicion of remote controllor에서는 Peak Wavelength = 940nm 부근의 IR을 주로 사용

		하지만 직접 실험해 본 결과

		이는 SIGNAL TRANSMITTING SYSTEM이 기능해주기 때문

		물론, 모든 전자부품이 그렇듯이 이 range 밖의 IR이 '전혀' 발산되지 않는다는 것은 아니다.

		Bandwidth을 주로 사용하는것이 좋지만, 그 range를 약간 벗어나더라도

		SIGNAL RECIEVING SYSTEM에서 감도가 약간 떨어질 뿐 communication이 전혀 불가능해지지는 않습니다.



	[TIP]

		IRED 사망 판별법

			멀티미터로 찍어서 확인

			전원을 연결한 뒤 휴대폰 카메라 등을 통해 확인

				(요즘의 smart phone 의 camera 에는 IR filter가 장착되어 있어서 카메라 렌즈에 최대한 밀착시켜서 보라색 불빛을 확인)



가시광선 FILTER

	검은색으로 된 LIQUID?

INFRARED RAYS FILTER





Phototransistor

	BLACK INFRARED RAYS RECIEVING TRANSISTOR

		외형은 LED와 비슷하게 생기며

		표면에 (가시광선 FILTER)가 발라짐

	CLEAR INFRARED RAYS RECIEVING TRANSISTOR

		외형은 LED와 비슷하게 생기며

		(가시광선)으로 인한 (간섭)이 발생할 수 있으므로 유의



[극성판별]

	current는 (짧은 다리)->(긴 다리) 방향으로 흐릅니다(LED/IRED와 다리 극성도 반대)

 	원통 하단의 잘린 귀퉁이가 짧은 다리(LED/IRED에서도 동일하게 적용됩니다.)



	(긴 다리)는 NPN형 TR의 Emitter에 해당

	(짧은 다리)는 Collector에 해당

	NPN- transistor에서 Base가 광수신부로 대체된 것이라고 이해하면 됩니다.

	수신되는 IR 광량에 따라 Collector에서 Emitter로 흐르는 current의 양이 변동



	수신하는 IR의 Bandwidth

		IRED에 비해 그 Bandwidth이 광range

		Phototransistor can cover 서로 다른 Peak Wavelength와 Bandwidth을 갖는 여러 IRED들





..............................................................................................................................................................................................................................................................................

IR communication

	즉 우리가 일반적으로 IR communication을 하는 공간에는 Noise가 존재를 하여 오작동을 할 수 있으므로

	불필요한 noise 영향 제거가 중요





	noise 제거 vs noise의 영향 제거

		noise 제거 가 가능하면 좋겠지만 주변환경에 대하여 모든 변수를 통제하는 것이 쉬운 일은 아니다

		우리는 noise 제거 보다는 noise의 영향 제거에 힘을 써야 한다







	통상 IR communication에서는 data를 보낼 때 특정 frequency를 갖는 Modulation Carrier에 싣는 과정을 거쳐서 전송

	(modulation을 하는 이유는 data를 정형화 시켜 noise의 제거를 쉽게 하기 위해서 인듯하다)

	(물론, 이는 electric wave를 사용하는 일반 communication에서도 마찬가지입니다.)

	IR communication에서 많이 사용되는 Modulation Frequency는 32.7kHz, 36.7kHz, 37.9kHz, 40.0kHz, 56.9kHz 등



Modulation Carrier

	0과 1이 반복되는 일종의 PWM 출력signal

	Duty Ratio(한 Cycle에서 1과 0의 시간 비율)는 크게 중요하지 않음

	단지 수신부와 동기화된 Carrier Frequency가 중요합니다.



	이렇게 Modulation된 signal를 수신측에서 송신측이 의도한 본래 signal로 되돌리려면 phototransistor로 수신한 signal를 Band Pass Filter(BPF)에 통과시켜서 Demodulation하는 과정을 거쳐야 합니다.





IR recieving module

	phototransistor와 특정 Center Frequency의 BPF를 결합하여 사용하기 편리하도록 하나의 부품으로 패키징해 제작한 부품

	수신되는 IR signal 중에서 특정 frequency의 IR signal만 분리해서 출력핀으로 내보내는 역할





	ex

		(KSM-603LM)







operation of IR recieving module

	[Transmitter]->Transmitter output->[(KSM-603LM)]->(Remocon output pulse)

	Carrier signal가 없을 때 Logical '1'을 출력

	Carrier signal가 수신될 때 Logical '0'을 출력

	이 signal을 MCU로 입력받아 Decoding(demodulation)을 수행하여 송신측에서 보낸 data를 알아낼 수 있습니다

	

photodiode를 MCU에 직결하지 않고 IR recieving module을 사용하는 이유

	MCU의 수신 signal 처리 부하를 줄이기 위함

	MCU에서 37.9kHz의 Carriersignal를 직접 수신해서 해석하려면 펌웨어 코딩도 여간 귀찮은 일이 아니겠지만

	무엇보다도 인터럽트를 통해 수신 signal를 처리하는 데 많은 양의 연산량이 요구되기 때문







	IR recieving module에서 나온 출력 signal는 송신부에서 보낸 signal(IRED의 깜박임)와 전혀 다르다는 점을 반드시 인지하고 있어야 합니다

	게다가, 송신 signal를 그대로 반전시킨것도 아닙니다.

	굳이 언급하자면, 송신부에서 보낸 signal의 Carrier를 모두 뭉개서 평평하게 만든 뒤 뒤집은 것(?)이라고 할 수 있습니다







 

IR transmitting circuit

	switch로 IRED를 켜고 끄기 위한 circuit 구성을 해보자

		이와 같은 구성을 한다면 modulation이 되지 않아서  

	MCU로 control를 한다고 한다면 

		1.MCU의 PWM output pin을 IR_Tx에 연결

		2.PWM Frequency를 사용할 Carrier Frequency에 맞추기

		3.PWM 출력을 communicaiton protocol에 따라 ON/OFF







IR recieving circuit(using phototransistor)

	phototransistor

		IR 신호가 들어오지 않을 때는 Collector-Emitter간 저항이 1㏁가까이 되지만

		IR 신호가 들어오면 1㏀정도까지 떨어집니다. 

		Base가 광수신부로 대체된 NPN트랜지스터라는 사실을 되새겨보면 간단한 수신 circuit를 구성할 수 있습니다.

	IR_Rx핀

		평상시에는 5.0V로 풀업

		IR이 수신되면 0V(정확히는 수백 mV)로 떨어집니다



	이 회로를 통해서 수신한 신호에는 Modulation Carrier까지 그대로 포함되어 있으므로 이를 MCU에서 decoding(demodulationg) 처리해 주어야 합니다.





IR recieving circuit(using IR recieving module)

	IR recieving module

		1.connect output pin of IR recieving module to MCU

	

	#IR_Rx is output signal of this circuit

	#IR_Rx is Demoulation된 신호가 반전되어 출력됨













MCU coding....................................................................................................................................................................................

Modulation Carrier

	noise에 의하니 영향을 제거하기 위해서 noise effct를 제거하기 위해 sending 할 signal을 Carrier에 싣는 Modulation 과정을 거쳐서 send signal







	modultion carrier를 잘 생각해보면 IRED를 더 자주 깜박이게 하는 것이다 

	잘 생각해보면 된다 on off timing 을 control 하는 것으로 noise effect를 줄이는 것이다





문득 든 생각인데 우리가 보는 signal에 대한 timing diagram은 이론적인 모습이며   실제로 측정을 한다면 MCU에서 demodulation이 되었을 때나 비슷해질 것 이다



	





조사와 실험 결과

	가전제품용 IRremote controllor

		38kHz(37.9kHz), 40kHz, 56kHz를 Carrier Frequency로 많이 사용

		Bandwidth을 갖기 때문에 frequency가 어느 정도 달라져도 무방



	삼성 벽걸이형 에어컨

	carrier freqeuncy=38kHz를 사용하지만 30kHz~50kHz range에서도 수신 감도가 약간 떨어질 뿐 정상적으로 제어가 가능



	LG에어컨

	carrier freqeuncy=38kHz





IR communication protocol

	IRED를 통해 Carrier

		출력되고 있는 상태를 'Mark'(혹은 'Burst')

		꺼져 있는 상태를 'Space'라고 합니다

	IR communication의 Data Frame은 이 Mark와 Space의 교대로 이루어지며, (당연한 말이지만) 시작과 끝은 항상 Mark가 됩니다.







	Data Frame

		구성은 'Mark'들과 'Space'들의 길이(Duration)이며 이는 제조사와 remote controllor마다 서로 다릅니다

		이는 같은 주파수의 Carrier를 사용하더라도 서로 다른 모델의 가전제품간에 혼선이 발생하지 않도록 하기 위함

		





	Mark부분에 세로빗금을 쳐놓은 이유

		이 부분이 IRED가 계속 켜져 있는 것이 아니라

		Carrier Frequency로 계속 깜박이고 있음을 나타내기 위함



	Header Mark: Data Frame의 시작을 나타냅니다.

	Header Space: Data의 시작을 나타냅니다.

	Bit Mark: Bit들을 구분합니다.

	Zero Space: Bit '0'을 나타냅니다.

	One Space: Bit '1'을 나타냅니다.







	Mark들과 Space들의 길이 및 한 Data Frame에 포함된 Bit의 수는 제조사와 가전제품마다 모두 다릅니다. 















MCU로 가전제품을 제어하기 위한 IR remote controllor을 구현하려면 

	해당 가전제품의 정품 IR remote controllor을 구해서 오실로스코프 등을 통해 이들 Timing Parameter들을 직접 찾아야 합니다

	물론, 찾아낸 Bit열에 포함된 의미를 해석하는 것은 또 다른 큰일입니다.













IR remote controllor

	MCU



how to find timing parameter

	1.Hardware Timer를 사용해서 Carrier Frequency의 PWM 파형을 생산해내도록 한 뒤 

	2.PWM 출력 핀을 ON/OFF하는 방식으로 Mark와 Space를 교대로 배치하여 Data Frame을 구성해야 합니다.

	finding 시 caution

		Modulation Carrier는 가급적 Timer를 이용해서 만들어야 한다는 점

		귀찮아서 Delay함수로 Carrier를 만들어내면 Carrier Frequency는 얼추 맞을지 몰라도

		Delay 함수의 오차가 누적되서 Mark의 전체 길이가 심각하게 달라져 버립니다.



LG air conditionor

	Data Frame

		length of Header Mark=8000㎲

	Carrier Frequency=38kHz 이므로 Header Mark 내에 약 304개의 Cycle이 존재

		한 Cycle은 ON과 OFF로 이루어지므로 Delay함수는 총 2*304=608번 사용

		여기서 Delay함수의 오차가 1㎲라고 가정하면 본디 8000㎲여야 할 Header Mark가 608㎲늘어나서 8608㎲가 되어 버립니다

		수신측(에어컨 본체)에서는 Header Mark가 수신된 뒤 사전에 설정된 길이인지 여부를 검사하여 수신 여부를 결정하므로

		이 Data Frame은 버려지게 됩니다.





	Timer를 이용해 Carrier를 만들어낸다면, Mark와 Space의 Duration은 다음과 같이 Carrier를 켜고 끄는 방식으로 제어해도 크게 문제가 되지 않습니다.



?

Carrier_ON();

Delay_us(8000); // Header Mark

Carrier_OFF();

Delay_us(4000); // Header Space

Carrier_ON();

Delay_us(600);  // Bit Mark

Carrier_OFF();

Delay_us(1600); // '1'

Carrier_ON();

Delay_us(600);  // Bit Mark

Carrier_OFF();

Delay_us(550);  // '0'

...

Delay_us(1600); // '1'

Carrier_ON();

Delay_us(600);  // Bit Mark

Carrier_OFF();

다만, 이 경우에도 중간에 인터럽드가 끼어들면 전체 Data Frame이 왜곡되어 전송이 실패하게 되므로

가급적이면 Delay를 사용하지 말고 Timer와 Interrupt를 이용해서 비동기식으로 전송하는 방법을 사용하는 것이 좋습니다.













IR communication에서 일반적으로 사용하는 modulation method

	▶ Bi-Phase

	▶ ASK or OOK (Amplitude Shift Keying or On-Off Keying)

	▶ PDM or PWM(Pulse Duration or Width Modulation)

 

Bi-Phase 방식

	한 비트를 반으로 쪼개서 상승엣지면 "1", 하강엣지면 "0"을 의미한다.



ASK 혹은 OOK방식

	가장 단순한 (진폭변조방식)이다.

	high인 시간은 같고 low인 시간을 달리하여 "0"과 "1"을 구별한다.



PDM 혹은 PWM방식

	high인 시간을 달리하여 "0"과 "1"을 구별한다.





 

 

나는 여기서 가장 간단한 OOK방식을 사용하였다.





프레임은 "시작비트+데이터크기+데이터+스톱비트" 으로 구성했다.

위처럼 구성한 이유는 보통의 serial communication은 1byte(8 bits)씩 보내게 되는데 받는사람 입장에서는 보내는 사람이 몇 문자를 전송할지 알 수 없기 때문에 보내고자하는 프레임의 크기도 같이 실어 보냈다.

 

 

이제 실제 AVR상에서 코딩을 어떻게 할지 알아보자.

 

먼저 IR 수신모듈(KSM-603)의 data sheet를 살펴보면..



37kHz에 실어 보내는 신호의 최소시간이 500us이상(일반적으로 600us)은 되어야 인식을 한다고 나와있다. 따라서 송신부에서의 필요사항은 37kHz를 만들기 위한 타이머, 500us를 체크하기위한 카운터 등이 필요하다. 그리고 위에서 언급했지만 나는 "0"과 "1"을 만들기 위해 OOK방식을 사용하므로 아래 그림과 같이 신호를 만들어줄 함수가 필요하다.

송신부의 전체 코드는 다음과 같다.



#define F_CPU 16000000UL

#include <avr/io.h>

#include <util/delay.h>

#include <avr/interrupt.h>

#include <string.h>

 

volatile unsigned int flag, count;

 

ISR(TIMER0_OVF_vect) // every 13us

{

    TCNT0 = 48;

    ++count;

 

    if(count == 35) // 500us

    {

        flag=1;

    }

}

 

void _one()

{

    flag=0;

    count=0;

    while(!flag)

    {

        if(count%2)

            PORTB = 0x00;

        else

            PORTB = 0x01;

    }

    PORTB = 0x00;

    flag=0;

    count=0;

    while(!flag);

}

 

void _zero()

{

    flag=0;

    count=0;

    while(!flag)

    {

        if(count%2)

        PORTB = 0x00;

        else

        PORTB = 0x01;

    }

    PORTB = 0x00;

    flag=0;

    count=0;

    while(!flag);

    flag=0;

    count=0;

    while(!flag);

}

 

void send_frame(unsigned char *data)

{

    int i=0,j=0,size;

     

    size = strlen(data);

     

    _delay_ms(5); // wait to distinguish the new frame

         

    _one(); // start bit

     

    while(i<8) // length of data

    {

        if((size<<i)&0x80)

            _one();

        else

            _zero();

        ++i;

    }

     

    while(j<size) // data

    {

        i=0;

        while(i<8)

        {

            if((*(data+j)<<i)&0x80)

                _one();

            else

                _zero();

            ++i;

        }

        ++j;

    }

     

    _one(); // end bit

}

 

int main()

{

    int i;

     

    TCCR0 = 0x01; // no prescale, normal mode

    TIMSK = 0x01; //TOV enable

    TCNT0 = 48; // 208 count => 13us

     

    DDRB = 0x01;

    sei();

 

    while(1)

    {

        send_frame("IR Success!!!");_delay_ms(500);

         

        for(i=48; i<58; i++) // numbers

        {

            send_frame(&i);

            _delay_ms(100);

        }

         

        for(i=97; i<123; i++) // small character

        {

            send_frame(&i);

            _delay_ms(100);

        }

         

        for(i=65; i<91; i++) // capital character

        {

            send_frame(&i);

            _delay_ms(100);

        }       

         

        send_frame("Ha-Ha-Ha-");_delay_ms(500);

    }

     

    return 0;

}



 

이제 수신부는 어떻게 구현하는지 아래 그림부터 먼저 보자.









IR 수신모듈은 IDEL상태에서는 high를 유지하고 있다. IR이 high를 쏴주면 수신모듈은 반대로 low로 떨어진다. 따라서 외부인터럽트를 사용해서 falling edge에서 감지되게 한다. 외부인터럽트가 걸리면 샘플링을 위해 만들어 놓은 50us짜리 타이머의 카운트를 0으로 초기화하고 다음 외부인터럽트가 걸릴 때까지 카운터를 증가시키고 다시 외부인터럽트가 걸리면 샘플링된 카운터의 수를 체크해서 "0"인지 "1"인지 판별한다. 내가 만든 코드에서 "1"은 카운터의 갯수가 약 22개, "0"일 때는 32개 정도 카운팅 되어서 threshold를 27로 했다. 즉 카운터의 수가 27보다 작으면 "1"로 판단하고 27보다 크면 "0"으로 판단한다.









수신부의 전체 코드는 다음과 같다.



/*

 * ir_communication.c

 *

 * Created: 2014-01-09 오후 3:47:45

 *  Author: JISU

 */

 

#define F_CPU 16000000UL

#include <avr/io.h>

#include <avr/interrupt.h>

#include <util/delay.h>

#include <string.h>

#include "lcd.h"

 

volatile unsigned int count;

volatile int temp_count;

volatile int sample_flag;

int val,size;

char buf[32];

 

ISR(TIMER0_OVF_vect) // every 50us

{

    TCNT0 = 160;

    ++count;        

}

 

ISR(INT3_vect)

{

    sample_flag=1;

    temp_count = count;

    count=0;

}

 

void detect_code()

{

    int i=0, j=0;

 

    while(1)

    {   

        if(count > 40000) // no signal for 2 seconds

        {

            PORTA = 0xff;

            memset(buf,32,sizeof(buf));

            break;

        }

         

        else if(count>90 && sample_flag)

        {

            memset(buf,32,sizeof(buf));

            val=0;

            sample_flag=0;          // start detect

            while(!sample_flag)

            {

                if(count>40000)

                {

                    PORTA = 0xff;

                    LCD_clear();

                    break;

                }

            }

            sample_flag=0;          // count throw away

            while(!sample_flag)

            {

                if(count>40000)

                {

                    PORTA = 0xff;

                    LCD_clear();

                    break;

                }

            }

            while(i<8)

            {

                sample_flag=0;

                while(!sample_flag)

                {

                    if(count>40000)

                    {

                        PORTA = 0xff;

                        LCD_clear();

                        break;

                    }

                }

                if(temp_count < 27) // distinguish 0 and 1 (if temp_count less than 27, then "1")

                    val += 1<<(7-i); // receive MSB first

                ++i;

            }

            size = val;

            j=0;

            while(j<size)

            {

                val=0;

                i=0;

                while(i<8)

                {

                    sample_flag=0;

                    while(!sample_flag)

                    {

                        if(count>40000)

                        {

                            PORTA = 0xff;

                            LCD_clear();

                            break;

                        }

                    }

                    if(temp_count < 27)

                    val += 1<<(7-i);

                    ++i;

                }

                buf[j] = val;

                ++j;

            }

            break;

        }

    }

}

 

void init_timer()

{

    TCCR0 = 0x02; // prescale 8, normal mode

    TIMSK = 0x01; //TOV enable

    TCNT0 = 160; // 100 count => 50us

}

 

void init_external()

{

    EICRA = 0x80; // falling edge(INT3)

    EIMSK = 0x08; // INT3 enable

}

 

void init_port()

{

    DDRA = 0xff; // LED

    PORTA = 0xff; // LED off

    DDRD = 0x00; // IR sensor

    DDRC = 0xff; // CLCD data

    DDRE = 0xff; // CLCD ctrl

}

 

int main(void)

{

    int arr[8];

    init_port();

    init_timer();

    init_external();

    LCD_initialize();

     

    sei();

     

    while(1)

    {

        detect_code();

        LCD_string(0x80, buf);

    }

}



 







































